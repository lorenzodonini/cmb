package applications;

import core.*;
import routing.ActiveRouter;
import tum_model.WebPage;
import tum_model.WebPageDb;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Random;

/**
 * This application is thought to be run on mobile nodes. It provides automatic message
 * generation within a variable time interval and handles responses to messages.<br>
 * Each request contains a unique identified for a desired WebPage, obtained randomly
 * from the {@link WebPageDb}. A response to a specific message contains the WebPage
 * associated to the requested ID.
 * The application itself does not handle routing policies, although it supports a caching mechanism.
 * <br>
 * Nodes exploiting an {@link routing.OffloadingRouter} are eligible to use this application.
 */
public class MobileWebApplication extends Application {

    /** The minimum time between two consecutive requests (i.e. message generation).
     * The idea of having a minimum and a maximum time allows to keep some degree of randomness
     * between nodes, while each individual node will have as a mean time between requests the
     * median between the min and the max interval values. Interval is expressed in seconds. */
    private int minRequestInterval;
    /** The maximum time between two consecutive requests (i.e. message generation).
     * The idea of having a minimum and a maximum time allows to keep some degree of randomness
     * between nodes, while each individual node will have as a mean time between requests the
     * median between the min and the max interval values. Interval is expressed in seconds. */
    private int maxRequestInterval;
    /** The size of a request in bytes */
    private int requestSize;
    /** Internal random object, needed for computing the time between two requests. */
    private Random mRandom;
    /** Inner variable used for keeping the absolute time at which the next request should be generated. */
    private int nextRequestTime;
    /** In case of offloading, the device might keep received responses in cache. If this is the case
     * then the device will be able to keep as many web pages as the size specified by this variable.
     * In case this value is <= 0, then no web pages are cached at all. */
    private int mCacheSize;
    /** The cached web pages, if any, are kept inside this list. This implementation uses a linked list,
     * to make the structure look like a queue and allow fast cache insertion/removal. */
    private LinkedList<WebPage> cachedWebPages;

    /** All messages generated by this application make use of a sequential ID. This global variable
     * allows to never have the same ID twice inside the same sinulation. */
    private static int mId = 1;

    //Settings
    /** Setting name for the maximum size of the cache */
    private static final String S_CACHE_SIZE = "cacheSize";
    /** Setting name for the desired interval span between requests */
    private final static String S_TIME_INTERVAL = "requestInterval";
    /** Setting name for the size of the request. Size in bytes. */
    private final static String S_REQ_SIZE = "requestSize";

    /** Application ID */
    public static final String APP_ID = "tum.cmb.team4.MobileWebApplication";

    /** Message Prefix */
    private final static String MESSAGE_PREFIX = "M";

    //Listener events
    public static final String E_RESP_RECEIVED = "ResponseReceived";
    public static final String E_REQ_SENT_P2P = "RequestSentP2P";
    public static final String E_REQ_SENT_OFFLOADED = "RequestSentOffloaded";
    public static final String E_REQ_SENT_WIFI = "RequestSentWifi";
    public static final String E_REQ_SENT_CELLULAR = "RequestSentCellular";
    //Types used by the application listener
    public static final byte REQ_TYPE_NONE = 0;
    public static final byte REQ_TYPE_CELLULAR = 1;
    public static final byte REQ_TYPE_WIFI = 2;
    public static final byte REQ_TYPE_OFFLOAD = 3;
    public static final byte REQ_TYPE_P2P = 4;
    //Property used for P2P responses
    public static final String PROP_P2P_RESPONSE = "p2pResponse";


    /** Proto constructor */
    public MobileWebApplication(Settings s) {
        int interval [] = s.getCsvInts(S_TIME_INTERVAL);
        minRequestInterval = interval[0];
        maxRequestInterval = interval[1];
        requestSize = s.getInt(S_REQ_SIZE);
        if (s.contains(S_CACHE_SIZE)) {
            mCacheSize = s.getInt(S_CACHE_SIZE);
        }
        else {
            mCacheSize = 0;
        }

        mRandom = new Random();
    }

    /** Copy constructor */
    public MobileWebApplication(MobileWebApplication other) {
        setAppListeners(other.getAppListeners());
        setAppID(APP_ID);

        minRequestInterval = other.minRequestInterval;
        maxRequestInterval = other.maxRequestInterval;
        requestSize = other.requestSize;
        mRandom = other.mRandom;
        mCacheSize = other.mCacheSize;
        if (mCacheSize > 0) {
            cachedWebPages = new LinkedList<>();
        }

        //Already setting the first wait time
        nextRequestTime = mRandom.nextInt(maxRequestInterval - minRequestInterval) + minRequestInterval;
    }

    /** Checks the internal cache for a specific {@link WebPage},
     * in order to provide P2P offloading functionality.
     * If the page associated to the passed id is in cache, it is returned, otherwise it
     * means that that page was not cached before (or has already been deleted).
     *
     * @param requestedId  The id of the WebPage that needs to be looked for.
     * @return  Returns the page associated to the id if found, null otherwise.
     */
    private WebPage checkCacheForWebPage(int requestedId) {
        if (cachedWebPages == null) {
            return null;
        }
        for (WebPage page: cachedWebPages) {
            if (page.id == requestedId) {
                return page;
            }
        }
        return null;
    }

    private void refreshItemInCache(WebPage wp) {
        Iterator<WebPage> it = cachedWebPages.iterator();
        while (it.hasNext()) {
            WebPage cached = it.next();
            /* In case we already have the same WebPage in cache, we still want to keep it in cache,
            but prioritize it accordingly, by bumping it to the end of the list. By doing this,
            we avoid having the same element multiple times in the cache. */
            if (cached.id == wp.id) {
                it.remove();
                return;
            }
        }
    }

    @Override
    public Message handle(Message msg, DTNHost host) {
        //Mobile nodes have passive behaviour only when doing P2P offloading. However,
        // we still want to remove requests from the message queue, once we received an answer.

        /* In case this is a valid response, we want to delete the original message
        from the router, otherwise the router will keep trying to send it until the TTL expires.
        This also works for replies from peers, as the ID contained in the request
        message will still be the same. */
        if (msg.getRequest() != null) {
            host.deleteMessage(msg.getRequest().getId(), false);
            //Reporting a received message
            sendEventToListeners(E_RESP_RECEIVED,msg,host);
        }

        //We check if there is a policy to keep some pages in cache
        if (mCacheSize <= 0) {
            //We don't cache anything, nothing else happens
            return msg;
        }

        Object lastWP = msg.getProperty(WebPageDb.WEB_PAGE_PROPERTY);
        if (lastWP != null) {
            //Handling a response message
            //Caching
            refreshItemInCache((WebPage)lastWP);
            if (cachedWebPages.size() >= mCacheSize) {
                cachedWebPages.removeFirst();
            }
            cachedWebPages.addLast((WebPage)lastWP);

            return msg;
        }

        Object requestedPage = msg.getProperty(WebPageDb.WEB_REQUESTED_ID_PROPERTY);
        if (requestedPage != null) {
            //Handling a page request message
            int requestedId = (int)requestedPage;
            //Checking our cache for a match
            for (WebPage page : cachedWebPages) {
                if (page.id == requestedId) {
                    //We indeed had the requested page in cache
                    String id = ActiveRouter.RESPONSE_PREFIX + msg.getId();

                    Message m = new Message(host,msg.getFrom(),id,page.size);
                    m.addProperty(WebPageDb.WEB_PAGE_PROPERTY, page);

                    //By setting the original request, we already have the full path, needed for routing purposes
                    m.setRequest(msg);
                    m.setAppID(MobileWebApplication.APP_ID);
                    m.addProperty(PROP_P2P_RESPONSE,true);

                    //Response message gets created, this will be routed inside the update function (of the router)
                    host.createNewMessage(m);
                    break;
                }
            }
            //If we don't have the requested web page in cache, we DO NOT send a reply
        }

        // Since we are not the final recipient of P2P messages, we don't want to store
        // the request message anyway. If we did, we would have to route it to the internet afterwards. Nope!
        return null;
    }

    @Override
    public void update(DTNHost host) {
        int current = SimClock.getIntTime();

        // Should start a new request
        if (current >= nextRequestTime) {
            DTNHost to = InfrastructureManager.getInstance().getInternetNode();
            String id = MESSAGE_PREFIX + mId;
            mId++;

            Message m = new Message(host, to, id, requestSize);
            //Adding the requested message ID property
            int randPage = WebPageDb.getInstance().getRandomPageId();
            m.addProperty(WebPageDb.WEB_REQUESTED_ID_PROPERTY, randPage);
            m.setAppID(InternetApplication.APP_ID);

            host.createNewMessage(m);

            //Check if we the application is using cache
            if (mCacheSize > 0) {
                //Checking if we are requesting a page we have in cache ourselves already
                if (checkCacheForWebPage(randPage) != null) {
                    // The same page is in cache already. No need to send out any requests, but to
                    // simulate the correct behavior we still create a response and handle it.
                    // Original message will be automatically deleted inside the handle method.
                    sendEventToListeners(E_REQ_SENT_P2P,new Object[] {m,SimClock.getTime()},host);
                    WebPage page = WebPageDb.getInstance().getPageById(randPage);
                    Message response = new Message(host, host,
                            ActiveRouter.RESPONSE_PREFIX + m.getId(), page.size);
                    response.setRequest(m);
                    response.addProperty(WebPageDb.WEB_PAGE_PROPERTY,page);
                    response.setAppID(MobileWebApplication.APP_ID);
                    // Response listener is called directly in the handle method
                    handle(response,host);
                }
            }

            //The application will generate another request at the below computed time
            nextRequestTime = current +
                    mRandom.nextInt(maxRequestInterval - minRequestInterval) + minRequestInterval;
        }
    }

    @Override
    public Application replicate() {
        return new MobileWebApplication(this);
    }
}

package applications;

import core.*;
import routing.ActiveRouter;
import routing.OffloadingRouter;
import tum_model.WebPage;
import tum_model.WebPageDb;

import java.util.LinkedList;
import java.util.List;
import java.util.Random;


public class MobileWebApplication extends Application {
    private final static String NS_TIME_INTERVAL = "requestInterval";
    private final static String NS_REQ_SIZE = "requestSize";

    /** The minimum time between two consecutive requests (i.e. message generation).
     * The idea of having a minimum and a maximum time allows to keep some degree of randomness
     * between nodes, while each individual node will have as a mean time between requests the
     * median between the min and the max interval values. Interval is expressed in seconds. */
    private int minRequestInterval;
    /** The maximum time between two consecutive requests (i.e. message generation).
     * The idea of having a minimum and a maximum time allows to keep some degree of randomness
     * between nodes, while each individual node will have as a mean time between requests the
     * median between the min and the max interval values. Interval is expressed in seconds. */
    private int maxRequestInterval;
    /** The size of a request in bytes */
    private int requestSize;
    /** Internal random object, needed for computing the time between two requests. */
    private Random mRandom;
    /** Inner variable used for keeping the absolute time at which the next request should be generated. */
    private int nextRequestTime;
    /** In case of offloading, the device might keep received responses in cache. If this is the case
     * then the device will be able to keep as many web pages as the size specified by this variable.
     * In case this value is <= 0, then no web pages are cached at all. */
    private int mCacheSize;
    /** The cached web pages, if any, are kept inside this list. This implementation uses a linked list,
     * to make the structure look like a queue and allow fast cache insertion/removal. */
    private LinkedList<WebPage> cachedWebPages;

    /** All messages generated by this application make use of a sequential ID. This global variable
     * allows to never have the same ID twice inside the same sinulation. */
    private static int mId = 1;

    //Settings
    /** Setting name for the maximum size of the cache */
    private static final String NS_CACHE_SIZE = "cacheSize";

    /** Application ID */
    public static final String APP_ID = "tum.cmb.team4.MobileWebApplication";

    /** Message Prefix */
    private final static String MESSAGE_PREFIX = "M";


    /** Proto constructor */
    public MobileWebApplication(Settings s) {
        int interval [] = s.getCsvInts(NS_TIME_INTERVAL);
        minRequestInterval = interval[0];
        maxRequestInterval = interval[1];
        requestSize = s.getInt(NS_REQ_SIZE);
        if (s.contains(NS_CACHE_SIZE)) {
            mCacheSize = s.getInt(NS_CACHE_SIZE);
        }
        else {
            mCacheSize = 0;
        }

        mRandom = new Random();
    }

    /** Copy constructor */
    public MobileWebApplication(MobileWebApplication other) {
        setAppListeners(other.getAppListeners());
        setAppID(APP_ID);

        minRequestInterval = other.minRequestInterval;
        maxRequestInterval = other.maxRequestInterval;
        requestSize = other.requestSize;
        mRandom = other.mRandom;
        mCacheSize = other.mCacheSize;
        if (mCacheSize > 0) {
            cachedWebPages = new LinkedList<>();
        }

        //Already setting the first wait time
        nextRequestTime = mRandom.nextInt(maxRequestInterval - minRequestInterval) + minRequestInterval;
    }

    private WebPage checkCacheForWebPage(int requestedId) {
        if (cachedWebPages == null) {
            return null;
        }
        for (WebPage page: cachedWebPages) {
            if (page.id == requestedId) {
                return page;
            }
        }
        return null;
    }

    @Override
    public Message handle(Message msg, DTNHost host) {
        //Mobile nodes have passive behaviour only when doing P2P offloading. However,
        // we still want to remove requests from the message queue, once we received an answer.

        /* In case this is a valid response, we want to delete the original message
        from the router, otherwise the router will keep trying to send it until the TTL expires.
        This also works for replies from peers, as the ID contained in the request
        message will still be the same. */
        if (msg.getRequest() != null) {
            host.deleteMessage(msg.getRequest().getId(), false);
        }

        //We check if there is a policy to keep some pages in cache
        if (msg.getTo() != host || mCacheSize <= 0) {
            //We don't cache anything, nothing else happens
            return msg;
        }

        Object lastWP = msg.getProperty(WebPageDb.WEB_PAGE_PROPERTY);
        if (lastWP != null) {
            //Handling a response message
            //Caching
            if (cachedWebPages.size() >= mCacheSize) {
                cachedWebPages.removeFirst();
            }
            cachedWebPages.addLast((WebPage)lastWP);

            return msg;
        }

        Object requestedPage = msg.getProperty(WebPageDb.WEB_REQUESTED_ID_PROPERTY);
        if (requestedPage != null) {
            //Handling a page request message
            int requestedId = (int)requestedPage;
            //Checking our cache for a match
            for (WebPage page : cachedWebPages) {
                if (page.id == requestedId) {
                    //We indeed had the requested page in cache
                    String id = ActiveRouter.RESPONSE_PREFIX + msg.getId();

                    Message m = new Message(host,msg.getFrom(),id,page.size);
                    m.addProperty(WebPageDb.WEB_PAGE_PROPERTY, page);

                    //By setting the original request, we already have the full path, needed for routing purposes
                    m.setRequest(msg);
                    m.setAppID(MobileWebApplication.APP_ID);

                    //Response message gets created, this will be routed inside the update function (of the router)
                    host.createNewMessage(m);
                    break;
                }
            }
            //If we don't have the requested web page in cache, we DO NOT send a reply
        }

        return msg;
    }

    @Override
    public void update(DTNHost host) {
        int current = SimClock.getIntTime();

        // Should start a new request
        if (current >= nextRequestTime) {
            DTNHost to = InfrastructureManager.getInstance().getInternetNode();
            String id = MESSAGE_PREFIX + mId;
            mId++;

            Message m = new Message(host, to, id, requestSize);
            //Adding the requested message ID property
            int randPage = WebPageDb.getInstance().getRandomPageId();
            m.addProperty(WebPageDb.WEB_REQUESTED_ID_PROPERTY, randPage);
            m.setAppID(InternetApplication.APP_ID);

            host.createNewMessage(m);

            //Check if we the application is using cache
            if (mCacheSize > 0) {
                //Checking if we are requesting a page we have in cache ourselves already
                if (checkCacheForWebPage(randPage) != null) {
                    //TODO: TO CHANGE
                    sendEventToListeners(id+" delivered to source host",null,host);
                    host.deleteMessage(id,false);
                }
            }

            //The application will generate another request at the below computed time
            nextRequestTime = current +
                    mRandom.nextInt(maxRequestInterval - minRequestInterval) + minRequestInterval;
        }
    }

    @Override
    public Application replicate() {
        return new MobileWebApplication(this);
    }
}
